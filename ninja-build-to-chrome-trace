#!/usr/bin/env python

"""Converts one (or several) .ninja_log files into chrome's about:tracing format

Usage:
    rm $BUILDDIR/.ninja_log && ninja -C $BUILDDIR
    ninja-build-to-chrome-trace $BUILDDIR/.ninja_log > trace.json

(If you don't have time for a clean build, at least run
`ninja -C $BUILDDIR -t recompact` first.)"""

import json
import os
import sys
import tempfile

def _InitPath():
  trace_viewer_path = os.path.join(
    os.path.dirname(__file__),
    'third_party', 'trace-viewer')
  if trace_viewer_path not in sys.path:
    sys.path.append(trace_viewer_path)
  try:
    from trace_viewer.build import trace2html
  except ImportError:
    sys.stderr.write("""trace-viewer submodule not found.

Did you forget to run this?
  git submodule update --init --recursive
""")

_InitPath()
from trace_viewer.build import trace2html

class Target:
    """Represents a single line read for a .ninja_log file."""
    def __init__(self, args):
        self.start, self.end, _, self.name, _ = args  # Ignore restat and hash.
        self.start = int(self.start)
        self.end = int(self.end)


class Threads:
    """Tries to reconstruct the parallelism from a .ninja_log"""
    def __init__(self):
        self.workers = []  # Maps thread id to time that thread is occupied for.

    def alloc(self, target):
        """Places target in an available thread, or adds a new thread."""
        for worker in range(len(self.workers)):
            if self.workers[worker] <= target.start:
                self.workers[worker] = target.end
                return worker
        self.workers.append(target.end)
        return len(self.workers) - 1


def read_targets(log_file):
    """Reads all targets from .ninja_log file |log_file|, sorted by start
    time."""
    with open(log_file, 'r') as f:
        header = f.readline()
        assert header == "# ninja log v5\n", \
               "unrecognized ninja log version %r" % header
        targets = [Target(line.strip().split('\t')) for line in f]
    return sorted(targets, key = lambda target: target.start)


def main(argv):
    entries = []
    for pid, log_file in enumerate(argv):
        threads = Threads()
        for target in read_targets(log_file):
            entries.append({
                'name': '%0s' % target.name, 'cat': 'target',
                'ph': 'X', 'ts': str(target.start * 1000),
                'dur': str((target.end - target.start) * 1000),
                'pid': str(pid), 'tid': str(threads.alloc(target)), 'args': {},
                })
    with tempfile.NamedTemporaryFile() as f:
      json.dump(entries, f)
      f.flush()
      trace2html.WriteHTMLForTracesToFile([f.name], sys.stdout)

if __name__ == '__main__':
    if len(sys.argv) > 1:
        sys.exit(main(sys.argv[1:]))
    print __doc__
